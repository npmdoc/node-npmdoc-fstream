<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/npm/fstream#readme">fstream (v1.0.11)</a>
</h1>
<h4>Advanced file system stream things</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream">module fstream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract">
            function <span class="apidocSignatureSpan">fstream.</span>Abstract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader">
            function <span class="apidocSignatureSpan">fstream.</span>DirReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter">
            function <span class="apidocSignatureSpan">fstream.</span>DirWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader">
            function <span class="apidocSignatureSpan">fstream.</span>FileReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter">
            function <span class="apidocSignatureSpan">fstream.</span>FileWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkReader">
            function <span class="apidocSignatureSpan">fstream.</span>LinkReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkWriter">
            function <span class="apidocSignatureSpan">fstream.</span>LinkWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader">
            function <span class="apidocSignatureSpan">fstream.</span>ProxyReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter">
            function <span class="apidocSignatureSpan">fstream.</span>ProxyWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader">
            function <span class="apidocSignatureSpan">fstream.</span>Reader
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer">
            function <span class="apidocSignatureSpan">fstream.</span>Writer
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.collect">
            function <span class="apidocSignatureSpan">fstream.</span>collect
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.socket_reader">
            function <span class="apidocSignatureSpan">fstream.</span>socket_reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Abstract.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Dir</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>DirReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>DirWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>File</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>FileReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>FileWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Link</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>LinkReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>LinkWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>ProxyReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>ProxyWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Reader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>Writer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.</span>socket_reader.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Abstract">module fstream.Abstract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.Abstract">
            function <span class="apidocSignatureSpan">fstream.</span>Abstract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.super_">
            function <span class="apidocSignatureSpan">fstream.Abstract.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Abstract.prototype">module fstream.Abstract.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.abort">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.destroy">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.error">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>error
            <span class="apidocSignatureSpan">(msg, code, th)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.info">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>info
            <span class="apidocSignatureSpan">(msg, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.on">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Abstract.prototype.warn">
            function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>warn
            <span class="apidocSignatureSpan">(msg, code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Dir">module fstream.Dir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Dir.Reader">
            function <span class="apidocSignatureSpan">fstream.Dir.</span>Reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Dir.Writer">
            function <span class="apidocSignatureSpan">fstream.Dir.</span>Writer
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.DirReader">module fstream.DirReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.DirReader">
            function <span class="apidocSignatureSpan">fstream.</span>DirReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.super_">
            function <span class="apidocSignatureSpan">fstream.DirReader.</span>super_
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.DirReader.prototype">module fstream.DirReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype._getEntries">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>_getEntries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype._read">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype.disown">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>disown
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype.emitEntry">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>emitEntry
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype.getChildProps">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>getChildProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype.pause">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>pause
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirReader.prototype.resume">
            function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>resume
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.DirWriter">module fstream.DirWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.DirWriter">
            function <span class="apidocSignatureSpan">fstream.</span>DirWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.super_">
            function <span class="apidocSignatureSpan">fstream.DirWriter.</span>super_
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.DirWriter.prototype">module fstream.DirWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.prototype._create">
            function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.prototype._process">
            function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>_process
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.prototype.add">
            function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>add
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.prototype.end">
            function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.DirWriter.prototype.write">
            function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.File">module fstream.File</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.File.Reader">
            function <span class="apidocSignatureSpan">fstream.File.</span>Reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.File.Writer">
            function <span class="apidocSignatureSpan">fstream.File.</span>Writer
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.FileReader">module fstream.FileReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.FileReader">
            function <span class="apidocSignatureSpan">fstream.</span>FileReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.super_">
            function <span class="apidocSignatureSpan">fstream.FileReader.</span>super_
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.FileReader.prototype">module fstream.FileReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.prototype._getStream">
            function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>_getStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.prototype._read">
            function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.prototype.pause">
            function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>pause
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileReader.prototype.resume">
            function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>resume
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.FileWriter">module fstream.FileWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.FileWriter">
            function <span class="apidocSignatureSpan">fstream.</span>FileWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.super_">
            function <span class="apidocSignatureSpan">fstream.FileWriter.</span>super_
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.FileWriter.prototype">module fstream.FileWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.prototype._create">
            function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.prototype._finish">
            function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>_finish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.prototype.end">
            function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>end
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.FileWriter.prototype.write">
            function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>write
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Link">module fstream.Link</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Link.Reader">
            function <span class="apidocSignatureSpan">fstream.Link.</span>Reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Link.Writer">
            function <span class="apidocSignatureSpan">fstream.Link.</span>Writer
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.LinkReader">module fstream.LinkReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkReader.LinkReader">
            function <span class="apidocSignatureSpan">fstream.</span>LinkReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkReader.super_">
            function <span class="apidocSignatureSpan">fstream.LinkReader.</span>super_
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.LinkReader.prototype">module fstream.LinkReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkReader.prototype._read">
            function <span class="apidocSignatureSpan">fstream.LinkReader.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkReader.prototype._stat">
            function <span class="apidocSignatureSpan">fstream.LinkReader.prototype.</span>_stat
            <span class="apidocSignatureSpan">(currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.LinkWriter">module fstream.LinkWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkWriter.LinkWriter">
            function <span class="apidocSignatureSpan">fstream.</span>LinkWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkWriter.super_">
            function <span class="apidocSignatureSpan">fstream.LinkWriter.</span>super_
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.LinkWriter.prototype">module fstream.LinkWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkWriter.prototype._create">
            function <span class="apidocSignatureSpan">fstream.LinkWriter.prototype.</span>_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.LinkWriter.prototype.end">
            function <span class="apidocSignatureSpan">fstream.LinkWriter.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Proxy">module fstream.Proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Proxy.Reader">
            function <span class="apidocSignatureSpan">fstream.Proxy.</span>Reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Proxy.Writer">
            function <span class="apidocSignatureSpan">fstream.Proxy.</span>Writer
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.ProxyReader">module fstream.ProxyReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.ProxyReader">
            function <span class="apidocSignatureSpan">fstream.</span>ProxyReader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.super_">
            function <span class="apidocSignatureSpan">fstream.ProxyReader.</span>super_
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.ProxyReader.prototype">module fstream.ProxyReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.prototype._addProxy">
            function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>_addProxy
            <span class="apidocSignatureSpan">(proxy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.prototype._stat">
            function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>_stat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.prototype.pause">
            function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyReader.prototype.resume">
            function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.ProxyWriter">module fstream.ProxyWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.ProxyWriter">
            function <span class="apidocSignatureSpan">fstream.</span>ProxyWriter
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.super_">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.</span>super_
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.ProxyWriter.prototype">module fstream.ProxyWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.prototype._addProxy">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>_addProxy
            <span class="apidocSignatureSpan">(proxy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.prototype._stat">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>_stat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.prototype.add">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>add
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.prototype.end">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>end
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.ProxyWriter.prototype.write">
            function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>write
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Reader">module fstream.Reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.Reader">
            function <span class="apidocSignatureSpan">fstream.</span>Reader
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.Dir">
            function <span class="apidocSignatureSpan">fstream.Reader.</span>Dir
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.File">
            function <span class="apidocSignatureSpan">fstream.Reader.</span>File
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.Link">
            function <span class="apidocSignatureSpan">fstream.Reader.</span>Link
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.Proxy">
            function <span class="apidocSignatureSpan">fstream.Reader.</span>Proxy
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.super_">
            function <span class="apidocSignatureSpan">fstream.Reader.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fstream.Reader.</span>hardLinks</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Reader.prototype">module fstream.Reader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.prototype._read">
            function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.prototype._stat">
            function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>_stat
            <span class="apidocSignatureSpan">(currentStat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.prototype.pause">
            function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>pause
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.prototype.pipe">
            function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Reader.prototype.resume">
            function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>resume
            <span class="apidocSignatureSpan">(who)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Writer">module fstream.Writer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.Writer">
            function <span class="apidocSignatureSpan">fstream.</span>Writer
            <span class="apidocSignatureSpan">(props, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.Dir">
            function <span class="apidocSignatureSpan">fstream.Writer.</span>Dir
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.File">
            function <span class="apidocSignatureSpan">fstream.Writer.</span>File
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.Link">
            function <span class="apidocSignatureSpan">fstream.Writer.</span>Link
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.Proxy">
            function <span class="apidocSignatureSpan">fstream.Writer.</span>Proxy
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.super_">
            function <span class="apidocSignatureSpan">fstream.Writer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fstream.Writer.</span>dirmode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fstream.Writer.</span>filemode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.Writer.prototype">module fstream.Writer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype._create">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype._finish">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_finish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype._stat">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_stat
            <span class="apidocSignatureSpan">(current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype.add">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype.pipe">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.Writer.prototype.write">
            function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.socket_reader">module fstream.socket_reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.socket_reader.socket_reader">
            function <span class="apidocSignatureSpan">fstream.</span>socket_reader
            <span class="apidocSignatureSpan">(props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.socket_reader.super_">
            function <span class="apidocSignatureSpan">fstream.socket_reader.</span>super_
            <span class="apidocSignatureSpan">(props, currentStat)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fstream.socket_reader.prototype">module fstream.socket_reader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fstream.socket_reader.prototype._read">
            function <span class="apidocSignatureSpan">fstream.socket_reader.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream" id="apidoc.module.fstream">module fstream</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Abstract" id="apidoc.element.fstream.Abstract">
        function <span class="apidocSignatureSpan">fstream.</span>Abstract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Abstract() {
  Stream.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader" id="apidoc.element.fstream.DirReader">
        function <span class="apidocSignatureSpan">fstream.</span>DirReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirReader(props) {
  var self = this
  if (!(self instanceof DirReader)) {
    throw new Error('DirReader must be called as constructor.')
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    throw new Error('Non-directory type ' + props.type)
  }

  self.entries = null
  self._index = -1
  self._paused = false
  self._length = -1

  if (props.sort) {
    this.sort = props.sort
  }

  Reader.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter" id="apidoc.element.fstream.DirWriter">
        function <span class="apidocSignatureSpan">fstream.</span>DirWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirWriter(props) {
  var self = this
  if (!(self instanceof DirWriter)) {
    self.error('DirWriter must be called as constructor.', null, true)
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    self.error('Non-directory type ' + props.type + ' ' +
      JSON.stringify(props), null, true)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileReader" id="apidoc.element.fstream.FileReader">
        function <span class="apidocSignatureSpan">fstream.</span>FileReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileReader(props) {
  // console.error("    FR create", props.path, props.size, new Error().stack)
  var self = this
  if (!(self instanceof FileReader)) {
    throw new Error('FileReader must be called as constructor.')
  }

  // should already be established as a File type
  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
  // with a HardLinkReader class.
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'File' &amp;&amp; props.File))) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesEmitted = 0
  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileWriter" id="apidoc.element.fstream.FileWriter">
        function <span class="apidocSignatureSpan">fstream.</span>FileWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileWriter(props) {
  var self = this
  if (!(self instanceof FileWriter)) {
    throw new Error('FileWriter must be called as constructor.')
  }

  // should already be established as a File type
  if (props.type !== 'File' || !props.File) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesWritten = 0

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkReader" id="apidoc.element.fstream.LinkReader">
        function <span class="apidocSignatureSpan">fstream.</span>LinkReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkReader(props) {
  var self = this
  if (!(self instanceof LinkReader)) {
    throw new Error('LinkReader must be called as constructor.')
  }

  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkWriter" id="apidoc.element.fstream.LinkWriter">
        function <span class="apidocSignatureSpan">fstream.</span>LinkWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkWriter(props) {
  var self = this
  if (!(self instanceof LinkWriter)) {
    throw new Error('LinkWriter must be called as constructor.')
  }

  // should already be established as a Link type
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  if (props.linkpath === '') props.linkpath = '.'
  if (!props.linkpath) {
    self.error('Need linkpath property to create ' + props.type)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyReader" id="apidoc.element.fstream.ProxyReader">
        function <span class="apidocSignatureSpan">fstream.</span>ProxyReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyReader(props) {
  var self = this
  if (!(self instanceof ProxyReader)) {
    throw new Error('ProxyReader must be called as constructor.')
  }

  self.props = props
  self._buffer = []
  self.ready = false

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter" id="apidoc.element.fstream.ProxyWriter">
        function <span class="apidocSignatureSpan">fstream.</span>ProxyWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyWriter(props) {
  var self = this
  if (!(self instanceof ProxyWriter)) {
    throw new Error('ProxyWriter must be called as constructor.')
  }

  self.props = props
  self._needDrain = false

  Writer.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader" id="apidoc.element.fstream.Reader">
        function <span class="apidocSignatureSpan">fstream.</span>Reader
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer" id="apidoc.element.fstream.Writer">
        function <span class="apidocSignatureSpan">fstream.</span>Writer
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.collect" id="apidoc.element.fstream.collect">
        function <span class="apidocSignatureSpan">fstream.</span>collect
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collect(stream) {
  if (stream._collected) return

  if (stream._paused) return stream.on('resume', collect.bind(null, stream))

  stream._collected = true
  stream.pause()

  stream.on('data', save)
  stream.on('end', save)
  var buf = []
  function save (b) {
    if (typeof b === 'string') b = new Buffer(b)
    if (Buffer.isBuffer(b) &amp;&amp; !b.length) return
    buf.push(b)
  }

  stream.on('entry', saveEntry)
  var entryBuffer = []
  function saveEntry (e) {
    collect(e)
    entryBuffer.push(e)
  }

  stream.on('proxy', proxyPause)
  function proxyPause (p) {
    p.pause()
  }

  // replace the pipe method with a new version that will
  // unlock the buffered stuff.  if you just call .pipe()
  // without a destination, then it'll re-play the events.
  stream.pipe = (function (orig) {
    return function (dest) {
      // console.error(' === open the pipes', dest &amp;&amp; dest.path)

      // let the entries flow through one at a time.
      // Once they're all done, then we can resume completely.
      var e = 0
      ;(function unblockEntry () {
        var entry = entryBuffer[e++]
        // console.error(" ==== unblock entry", entry &amp;&amp; entry.path)
        if (!entry) return resume()
        entry.on('end', unblockEntry)
        if (dest) dest.add(entry)
        else stream.emit('entry', entry)
      })()

      function resume () {
        stream.removeListener('entry', saveEntry)
        stream.removeListener('data', save)
        stream.removeListener('end', save)

        stream.pipe = orig
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.resume()
      }

      return dest
    }
  })(stream.pipe)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.socket_reader" id="apidoc.element.fstream.socket_reader">
        function <span class="apidocSignatureSpan">fstream.</span>socket_reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketReader(props) {
  var self = this
  if (!(self instanceof SocketReader)) {
    throw new Error('SocketReader must be called as constructor.')
  }

  if (!(props.type === 'Socket' &amp;&amp; props.Socket)) {
    throw new Error('Non-socket type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Abstract" id="apidoc.module.fstream.Abstract">module fstream.Abstract</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Abstract.Abstract" id="apidoc.element.fstream.Abstract.Abstract">
        function <span class="apidocSignatureSpan">fstream.</span>Abstract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Abstract() {
  Stream.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.super_" id="apidoc.element.fstream.Abstract.super_">
        function <span class="apidocSignatureSpan">fstream.Abstract.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Abstract.prototype" id="apidoc.module.fstream.Abstract.prototype">module fstream.Abstract.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.abort" id="apidoc.element.fstream.Abstract.prototype.abort">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
  this._aborted = true
  this.emit('abort')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.destroy" id="apidoc.element.fstream.Abstract.prototype.destroy">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.error" id="apidoc.element.fstream.Abstract.prototype.error">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>error
        <span class="apidocSignatureSpan">(msg, code, th)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (msg, code, th) {
  var er = decorate(msg, code, this)
  if (th) throw er
  else this.emit('error', er)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // replace the pipe method with a new version that will
  // unlock the buffered stuff.  if you just call .pipe()
  // without a destination, then it'll re-play the events.
  stream.pipe = (function (orig) {
    return function (dest) {
// console.<span class="apidocCodeKeywordSpan">error</span>(' === open the pipes', dest &amp;&amp; dest.path)

// let the entries flow through one at a time.
// Once they're all done, then we can resume completely.
var e = 0
;(function unblockEntry () {
  var entry = entryBuffer[e++]
  // console.error(" ==== unblock entry", entry &amp;&amp; entry.path)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.info" id="apidoc.element.fstream.Abstract.prototype.info">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>info
        <span class="apidocSignatureSpan">(msg, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function (msg, code) {
  this.emit('info', msg, code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.on" id="apidoc.element.fstream.Abstract.prototype.on">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, fn) {
  if (ev === 'ready' &amp;&amp; this.ready) {
    process.nextTick(fn.bind(this))
  } else {
    Stream.prototype.on.call(this, ev, fn)
  }
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


module.exports = collect

function collect (stream) {
if (stream._collected) return

if (stream._paused) return stream.<span class="apidocCodeKeywordSpan">on</span>('resume', collect.bind(null, stream))

stream._collected = true
stream.pause()

stream.on('data', save)
stream.on('end', save)
var buf = []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Abstract.prototype.warn" id="apidoc.element.fstream.Abstract.prototype.warn">
        function <span class="apidocSignatureSpan">fstream.Abstract.prototype.</span>warn
        <span class="apidocSignatureSpan">(msg, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function (msg, code) {
  var self = this
  var er = decorate(msg, code, self)
  if (!self.listeners('warn')) {
    console.error('%s %s\n' +
    'path = %s\n' +
    'syscall = %s\n' +
    'fstream_type = %s\n' +
    'fstream_path = %s\n' +
    'fstream_unc_path = %s\n' +
    'fstream_class = %s\n' +
    'fstream_stack =\n%s\n',
      code || 'UNKNOWN',
      er.stack,
      er.path,
      er.syscall,
      er.fstream_type,
      er.fstream_path,
      er.fstream_unc_path,
      er.fstream_class,
      er.fstream_stack.join('\n'))
  } else {
    self.emit('warn', er)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Dir" id="apidoc.module.fstream.Dir">module fstream.Dir</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Dir.Reader" id="apidoc.element.fstream.Dir.Reader">
        function <span class="apidocSignatureSpan">fstream.Dir.</span>Reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirReader(props) {
  var self = this
  if (!(self instanceof DirReader)) {
    throw new Error('DirReader must be called as constructor.')
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    throw new Error('Non-directory type ' + props.type)
  }

  self.entries = null
  self._index = -1
  self._paused = false
  self._length = -1

  if (props.sort) {
    this.sort = props.sort
  }

  Reader.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Dir.Writer" id="apidoc.element.fstream.Dir.Writer">
        function <span class="apidocSignatureSpan">fstream.Dir.</span>Writer
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirWriter(props) {
  var self = this
  if (!(self instanceof DirWriter)) {
    self.error('DirWriter must be called as constructor.', null, true)
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    self.error('Non-directory type ' + props.type + ' ' +
      JSON.stringify(props), null, true)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.DirReader" id="apidoc.module.fstream.DirReader">module fstream.DirReader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.DirReader.DirReader" id="apidoc.element.fstream.DirReader.DirReader">
        function <span class="apidocSignatureSpan">fstream.</span>DirReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirReader(props) {
  var self = this
  if (!(self instanceof DirReader)) {
    throw new Error('DirReader must be called as constructor.')
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    throw new Error('Non-directory type ' + props.type)
  }

  self.entries = null
  self._index = -1
  self._paused = false
  self._length = -1

  if (props.sort) {
    this.sort = props.sort
  }

  Reader.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.super_" id="apidoc.element.fstream.DirReader.super_">
        function <span class="apidocSignatureSpan">fstream.DirReader.</span>super_
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.DirReader.prototype" id="apidoc.module.fstream.DirReader.prototype">module fstream.DirReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype._getEntries" id="apidoc.element.fstream.DirReader.prototype._getEntries">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>_getEntries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getEntries = function () {
  var self = this

  // race condition.  might pause() before calling _getEntries,
  // and then resume, and try to get them a second time.
  if (self._gotEntries) return
  self._gotEntries = true

  fs.readdir(self._path, function (er, entries) {
    if (er) return self.error(er)

    self.entries = entries

    self.emit('entries', entries)
    if (self._paused) self.once('resume', processEntries)
    else processEntries()

    function processEntries () {
      self._length = self.entries.length
      if (typeof self.sort === 'function') {
        self.entries = self.entries.sort(self.sort.bind(self))
      }
      self._read()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype._read" id="apidoc.element.fstream.DirReader.prototype._read">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  var self = this

  if (!self.entries) return self._getEntries()

  if (self._paused || self._currentEntry || self._aborted) {
    // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)
    return
  }

  self._index++
  if (self._index &gt;= self.entries.length) {
    if (!self._ended) {
      self._ended = true
      self.emit('end')
      self.emit('close')
    }
    return
  }

  // ok, handle this one, then.

  // save creating a proxy, by stat'ing the thing now.
  var p = path.resolve(self._path, self.entries[self._index])
  assert(p !== self._path)
  assert(self.entries[self._index])

  // set this to prevent trying to _read() again in the stat time.
  self._currentEntry = p
  fs[ self.props.follow ? 'stat' : 'lstat' ](p, function (er, stat) {
    if (er) return self.error(er)

    var who = self._proxy || self

    stat.path = p
    stat.basename = path.basename(p)
    stat.dirname = path.dirname(p)
    var childProps = self.getChildProps.call(who, stat)
    childProps.path = p
    childProps.basename = path.basename(p)
    childProps.dirname = path.dirname(p)

    var entry = Reader(childProps, stat)

    // console.error("DR Entry", p, stat.size)

    self._currentEntry = entry

    // "entry" events are for direct entries in a specific dir.
    // "child" events are for any and all children at all levels.
    // This nomenclature is not completely final.

    entry.on('pause', function (who) {
      if (!self._paused &amp;&amp; !entry._disowned) {
        self.pause(who)
      }
    })

    entry.on('resume', function (who) {
      if (self._paused &amp;&amp; !entry._disowned) {
        self.resume(who)
      }
    })

    entry.on('stat', function (props) {
      self.emit('_entryStat', entry, props)
      if (entry._aborted) return
      if (entry._paused) {
        entry.once('resume', function () {
          self.emit('entryStat', entry, props)
        })
      } else self.emit('entryStat', entry, props)
    })

    entry.on('ready', function EMITCHILD () {
      // console.error("DR emit child", entry._path)
      if (self._paused) {
        // console.error("  DR emit child - try again later")
        // pause the child, and emit the "entry" event once we drain.
        // console.error("DR pausing child entry")
        entry.pause(self)
        return self.once('resume', EMITCHILD)
      }

      // skip over sockets.  they can't be piped around properly,
      // so there's really no sense even acknowledging them.
      // if someone really wants to see them, they can listen to
      // the "socket" events.
      if (entry.type === 'Socket') {
        self.emit('socket', entry)
      } else {
        self.emitEntry(entry)
      }
    })

    var ended = false
    entry.on('close', onend)
    entry.on('disown', onend)
    function onend () {
      if (ended) return
      ended = true
      self.emit('childEnd', entry)
      self.emit('entryEnd', entry)
      self._currentEntry = null
      if (!self._paused) {
        self._read()
      }
    }

    // XXX Remove this.  Works in node as of 0.6.2 or so.
    // Long filenames should not break stuff.
    entry.on('error', function (er) {
      if (entry._swallowErrors) {
        self.warn(er)
        entry.emit('end')
        entry.emit('close')
      } else {
        self.emit('error', er)
      }
    })

    // proxy up some events.
    ;[
      'child',
      'childEnd',
      'warn'
    ].forEach(function (ev) {
      entry.on(ev, self.emit.bind(self, ev))
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype.disown" id="apidoc.element.fstream.DirReader.prototype.disown">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>disown
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disown = function (entry) {
  entry.emit('beforeDisown')
  entry._disowned = true
  entry.parent = entry.root = null
  if (entry === this._currentEntry) {
    this._currentEntry = null
  }
  entry.emit('disown')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype.emitEntry" id="apidoc.element.fstream.DirReader.prototype.emitEntry">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>emitEntry
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitEntry = function (entry) {
  this.emit('entry', entry)
  this.emit('child', entry)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype.getChildProps" id="apidoc.element.fstream.DirReader.prototype.getChildProps">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>getChildProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChildProps = function () {
  return {
    depth: this.depth + 1,
    root: this.root || this,
    parent: this,
    follow: this.follow,
    filter: this.filter,
    sort: this.props.sort,
    hardlinks: this.props.hardlinks
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype.pause" id="apidoc.element.fstream.DirReader.prototype.pause">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>pause
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (who) {
  var self = this
  if (self._paused) return
  who = who || self
  self._paused = true
  if (self._currentEntry &amp;&amp; self._currentEntry.pause) {
    self._currentEntry.pause(who)
  }
  self.emit('pause', who)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function collect (stream) {
if (stream._collected) return

if (stream._paused) return stream.on('resume', collect.bind(null, stream))

stream._collected = true
stream.<span class="apidocCodeKeywordSpan">pause</span>()

stream.on('data', save)
stream.on('end', save)
var buf = []
function save (b) {
  if (typeof b === 'string') b = new Buffer(b)
  if (Buffer.isBuffer(b) &amp;&amp; !b.length) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirReader.prototype.resume" id="apidoc.element.fstream.DirReader.prototype.resume">
        function <span class="apidocSignatureSpan">fstream.DirReader.prototype.</span>resume
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (who) {
  var self = this
  if (!self._paused) return
  who = who || self

  self._paused = false
  // console.error('DR Emit Resume', self._path)
  self.emit('resume', who)
  if (self._paused) {
    // console.error('DR Re-paused', self._path)
    return
  }

  if (self._currentEntry) {
    if (self._currentEntry.resume) self._currentEntry.resume(who)
  } else self._read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.<span class="apidocCodeKeywordSpan">resume</span>()
      }

      return dest
    }
  })(stream.pipe)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.DirWriter" id="apidoc.module.fstream.DirWriter">module fstream.DirWriter</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.DirWriter.DirWriter" id="apidoc.element.fstream.DirWriter.DirWriter">
        function <span class="apidocSignatureSpan">fstream.</span>DirWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirWriter(props) {
  var self = this
  if (!(self instanceof DirWriter)) {
    self.error('DirWriter must be called as constructor.', null, true)
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    self.error('Non-directory type ' + props.type + ' ' +
      JSON.stringify(props), null, true)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter.super_" id="apidoc.element.fstream.DirWriter.super_">
        function <span class="apidocSignatureSpan">fstream.DirWriter.</span>super_
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.DirWriter.prototype" id="apidoc.module.fstream.DirWriter.prototype">module fstream.DirWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.DirWriter.prototype._create" id="apidoc.element.fstream.DirWriter.prototype._create">
        function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_create = function () {
  var self = this
  mkdir(self._path, Writer.dirmode, function (er) {
    if (er) return self.error(er)
    // ready to start getting entries!
    self.ready = true
    self.emit('ready')
    self._process()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter.prototype._process" id="apidoc.element.fstream.DirWriter.prototype._process">
        function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>_process
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_process = function () {
  var self = this

  // console.error('DW Process p=%j', self._processing, self.basename)

  if (self._processing) return

  var entry = self._buffer.shift()
  if (!entry) {
    // console.error("DW Drain")
    self.emit('drain')
    if (self._ended) self._finish()
    return
  }

  self._processing = true
  // console.error("DW Entry", entry._path)

  self.emit('entry', entry)

  // ok, add this entry
  //
  // don't allow recursive copying
  var p = entry
  var pp
  do {
    pp = p._path || p.path
    if (pp === self.root._path || pp === self._path ||
      (pp &amp;&amp; pp.indexOf(self._path) === 0)) {
      // console.error('DW Exit (recursive)', entry.basename, self._path)
      self._processing = false
      if (entry._collected) entry.pipe()
      return self._process()
    }
    p = p.parent
  } while (p)

  // console.error("DW not recursive")

  // chop off the entry's root dir, replace with ours
  var props = {
    parent: self,
    root: self.root || self,
    type: entry.type,
    depth: self.depth + 1
  }

  pp = entry._path || entry.path || entry.props.path
  if (entry.parent) {
    pp = pp.substr(entry.parent._path.length + 1)
  }
  // get rid of any ../../ shenanigans
  props.path = path.join(self.path, path.join('/', pp))

  // if i have a filter, the child should inherit it.
  props.filter = self.filter

  // all the rest of the stuff, copy over from the source.
  Object.keys(entry.props).forEach(function (k) {
    if (!props.hasOwnProperty(k)) {
      props[k] = entry.props[k]
    }
  })

  // not sure at this point what kind of writer this is.
  var child = self._currentChild = new Writer(props)
  child.on('ready', function () {
    // console.error("DW Child Ready", child.type, child._path)
    // console.error("  resuming", entry._path)
    entry.pipe(child)
    entry.resume()
  })

  // XXX Make this work in node.
  // Long filenames should not break stuff.
  child.on('error', function (er) {
    if (child._swallowErrors) {
      self.warn(er)
      child.emit('end')
      child.emit('close')
    } else {
      self.emit('error', er)
    }
  })

  // we fire _end internally *after* end, so that we don't move on
  // until any "end" listeners have had their chance to do stuff.
  child.on('close', onend)
  var ended = false
  function onend () {
    if (ended) return
    ended = true
    // console.error("* DW Child end", child.basename)
    self._currentChild = null
    self._processing = false
    self._process()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter.prototype.add" id="apidoc.element.fstream.DirWriter.prototype.add">
        function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>add
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (entry) {
  var self = this

  // console.error('\tadd', entry._path, '-&gt;', self._path)
  collect(entry)
  if (!self.ready || self._currentEntry) {
    self._buffer.push(entry)
    return false
  }

  // create a new writer, and pipe the incoming entry into it.
  if (self._ended) {
    return self.error('add after end')
  }

  self._buffer.push(entry)
  self._process()

  return this._buffer.length === 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Once they're all done, then we can resume completely.
var e = 0
;(function unblockEntry () {
  var entry = entryBuffer[e++]
  // console.error(" ==== unblock entry", entry &amp;&amp; entry.path)
  if (!entry) return resume()
  entry.on('end', unblockEntry)
  if (dest) dest.<span class="apidocCodeKeywordSpan">add</span>(entry)
  else stream.emit('entry', entry)
})()

function resume () {
  stream.removeListener('entry', saveEntry)
  stream.removeListener('data', save)
  stream.removeListener('end', save)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter.prototype.end" id="apidoc.element.fstream.DirWriter.prototype.end">
        function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this._ended = true
  this._process()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .<span class="apidocCodeKeywordSpan">end</span>()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.DirWriter.prototype.write" id="apidoc.element.fstream.DirWriter.prototype.write">
        function <span class="apidocSignatureSpan">fstream.DirWriter.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .<span class="apidocCodeKeywordSpan">write</span>("hello\n")
  .end()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.File" id="apidoc.module.fstream.File">module fstream.File</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.File.Reader" id="apidoc.element.fstream.File.Reader">
        function <span class="apidocSignatureSpan">fstream.File.</span>Reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileReader(props) {
  // console.error("    FR create", props.path, props.size, new Error().stack)
  var self = this
  if (!(self instanceof FileReader)) {
    throw new Error('FileReader must be called as constructor.')
  }

  // should already be established as a File type
  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
  // with a HardLinkReader class.
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'File' &amp;&amp; props.File))) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesEmitted = 0
  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.File.Writer" id="apidoc.element.fstream.File.Writer">
        function <span class="apidocSignatureSpan">fstream.File.</span>Writer
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileWriter(props) {
  var self = this
  if (!(self instanceof FileWriter)) {
    throw new Error('FileWriter must be called as constructor.')
  }

  // should already be established as a File type
  if (props.type !== 'File' || !props.File) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesWritten = 0

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.FileReader" id="apidoc.module.fstream.FileReader">module fstream.FileReader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.FileReader.FileReader" id="apidoc.element.fstream.FileReader.FileReader">
        function <span class="apidocSignatureSpan">fstream.</span>FileReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileReader(props) {
  // console.error("    FR create", props.path, props.size, new Error().stack)
  var self = this
  if (!(self instanceof FileReader)) {
    throw new Error('FileReader must be called as constructor.')
  }

  // should already be established as a File type
  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
  // with a HardLinkReader class.
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'File' &amp;&amp; props.File))) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesEmitted = 0
  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileReader.super_" id="apidoc.element.fstream.FileReader.super_">
        function <span class="apidocSignatureSpan">fstream.FileReader.</span>super_
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.FileReader.prototype" id="apidoc.module.fstream.FileReader.prototype">module fstream.FileReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.FileReader.prototype._getStream" id="apidoc.element.fstream.FileReader.prototype._getStream">
        function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>_getStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getStream = function () {
  var self = this
  var stream = self._stream = fs.createReadStream(self._path, self.props)

  if (self.props.blksize) {
    stream.bufferSize = self.props.blksize
  }

  stream.on('open', self.emit.bind(self, 'open'))

  stream.on('data', function (c) {
    // console.error('\t\t%d %s', c.length, self.basename)
    self._bytesEmitted += c.length
    // no point saving empty chunks
    if (!c.length) {
      return
    } else if (self._paused || self._buffer.length) {
      self._buffer.push(c)
      self._read()
    } else self.emit('data', c)
  })

  stream.on('end', function () {
    if (self._paused || self._buffer.length) {
      // console.error('FR Buffering End', self._path)
      self._buffer.push(EOF)
      self._read()
    } else {
      self.emit('end')
    }

    if (self._bytesEmitted !== self.props.size) {
      self.error("Didn't get expected byte count\n" +
        'expect: ' + self.props.size + '\n' +
        'actual: ' + self._bytesEmitted)
    }
  })

  stream.on('close', function () {
    if (self._paused || self._buffer.length) {
      // console.error('FR Buffering Close', self._path)
      self._buffer.push(CLOSE)
      self._read()
    } else {
      // console.error('FR close 1', self._path)
      self.emit('close')
    }
  })

  stream.on('error', function (e) {
    self.emit('error', e)
  })

  self._read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileReader.prototype._read" id="apidoc.element.fstream.FileReader.prototype._read">
        function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  var self = this
  // console.error('FR _read', self._path)
  if (self._paused) {
    // console.error('FR _read paused', self._path)
    return
  }

  if (!self._stream) {
    // console.error('FR _getStream calling', self._path)
    return self._getStream()
  }

  // clear out the buffer, if there is one.
  if (self._buffer.length) {
    // console.error('FR _read has buffer', self._buffer.length, self._path)
    var buf = self._buffer
    for (var i = 0, l = buf.length; i &lt; l; i++) {
      var c = buf[i]
      if (c === EOF) {
        // console.error('FR Read emitting buffered end', self._path)
        self.emit('end')
      } else if (c === CLOSE) {
        // console.error('FR Read emitting buffered close', self._path)
        self.emit('close')
      } else {
        // console.error('FR Read emitting buffered data', self._path)
        self.emit('data', c)
      }

      if (self._paused) {
        // console.error('FR Read Re-pausing at '+i, self._path)
        self._buffer = buf.slice(i)
        return
      }
    }
    self._buffer.length = 0
  }
// console.error("FR _read done")
// that's about all there is to it.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileReader.prototype.pause" id="apidoc.element.fstream.FileReader.prototype.pause">
        function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>pause
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (who) {
  var self = this
  // console.error('FR Pause', self._path)
  if (self._paused) return
  who = who || self
  self._paused = true
  if (self._stream) self._stream.pause()
  self.emit('pause', who)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function collect (stream) {
if (stream._collected) return

if (stream._paused) return stream.on('resume', collect.bind(null, stream))

stream._collected = true
stream.<span class="apidocCodeKeywordSpan">pause</span>()

stream.on('data', save)
stream.on('end', save)
var buf = []
function save (b) {
  if (typeof b === 'string') b = new Buffer(b)
  if (Buffer.isBuffer(b) &amp;&amp; !b.length) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileReader.prototype.resume" id="apidoc.element.fstream.FileReader.prototype.resume">
        function <span class="apidocSignatureSpan">fstream.FileReader.prototype.</span>resume
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (who) {
  var self = this
  // console.error('FR Resume', self._path)
  if (!self._paused) return
  who = who || self
  self.emit('resume', who)
  self._paused = false
  if (self._stream) self._stream.resume()
  self._read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.<span class="apidocCodeKeywordSpan">resume</span>()
      }

      return dest
    }
  })(stream.pipe)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.FileWriter" id="apidoc.module.fstream.FileWriter">module fstream.FileWriter</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.FileWriter.FileWriter" id="apidoc.element.fstream.FileWriter.FileWriter">
        function <span class="apidocSignatureSpan">fstream.</span>FileWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileWriter(props) {
  var self = this
  if (!(self instanceof FileWriter)) {
    throw new Error('FileWriter must be called as constructor.')
  }

  // should already be established as a File type
  if (props.type !== 'File' || !props.File) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesWritten = 0

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileWriter.super_" id="apidoc.element.fstream.FileWriter.super_">
        function <span class="apidocSignatureSpan">fstream.FileWriter.</span>super_
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.FileWriter.prototype" id="apidoc.module.fstream.FileWriter.prototype">module fstream.FileWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.FileWriter.prototype._create" id="apidoc.element.fstream.FileWriter.prototype._create">
        function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_create = function () {
  var self = this
  if (self._stream) return

  var so = {}
  if (self.props.flags) so.flags = self.props.flags
  so.mode = Writer.filemode
  if (self._old &amp;&amp; self._old.blksize) so.bufferSize = self._old.blksize

  self._stream = fs.createWriteStream(self._path, so)

  self._stream.on('open', function () {
    // console.error("FW open", self._buffer, self._path)
    self.ready = true
    self._buffer.forEach(function (c) {
      if (c === EOF) self._stream.end()
      else self._stream.write(c)
    })
    self.emit('ready')
    // give this a kick just in case it needs it.
    self.emit('drain')
  })

  self._stream.on('error', function (er) { self.emit('error', er) })

  self._stream.on('drain', function () { self.emit('drain') })

  self._stream.on('close', function () {
    // console.error('\n\nFW Stream Close', self._path, self.size)
    self._finish()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileWriter.prototype._finish" id="apidoc.element.fstream.FileWriter.prototype._finish">
        function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>_finish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finish = function () {
  var self = this
  if (typeof self.size === 'number' &amp;&amp; self._bytesWritten !== self.size) {
    self.error(
      'Did not get expected byte count.\n' +
      'expect: ' + self.size + '\n' +
      'actual: ' + self._bytesWritten)
  }
  Writer.prototype._finish.call(self)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileWriter.prototype.end" id="apidoc.element.fstream.FileWriter.prototype.end">
        function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>end
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (c) {
  var self = this

  if (c) self.write(c)

  if (!self.ready) {
    self._buffer.push(EOF)
    return false
  }

  return self._stream.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .<span class="apidocCodeKeywordSpan">end</span>()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.FileWriter.prototype.write" id="apidoc.element.fstream.FileWriter.prototype.write">
        function <span class="apidocSignatureSpan">fstream.FileWriter.prototype.</span>write
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (c) {
  var self = this

  self._bytesWritten += c.length

  if (!self.ready) {
    if (!Buffer.isBuffer(c) &amp;&amp; typeof c !== 'string') {
      throw new Error('invalid write data')
    }
    self._buffer.push(c)
    return false
  }

  var ret = self._stream.write(c)
  // console.error('\t-- fw wrote, _stream says', ret, self._stream._queue.length)

  // allow 2 buffered writes, because otherwise there's just too
  // much stop and go bs.
  if (ret === false &amp;&amp; self._stream._queue) {
    return self._stream._queue.length &lt;= 2
  } else {
    return ret
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .<span class="apidocCodeKeywordSpan">write</span>("hello\n")
  .end()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Link" id="apidoc.module.fstream.Link">module fstream.Link</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Link.Reader" id="apidoc.element.fstream.Link.Reader">
        function <span class="apidocSignatureSpan">fstream.Link.</span>Reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkReader(props) {
  var self = this
  if (!(self instanceof LinkReader)) {
    throw new Error('LinkReader must be called as constructor.')
  }

  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Link.Writer" id="apidoc.element.fstream.Link.Writer">
        function <span class="apidocSignatureSpan">fstream.Link.</span>Writer
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkWriter(props) {
  var self = this
  if (!(self instanceof LinkWriter)) {
    throw new Error('LinkWriter must be called as constructor.')
  }

  // should already be established as a Link type
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  if (props.linkpath === '') props.linkpath = '.'
  if (!props.linkpath) {
    self.error('Need linkpath property to create ' + props.type)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.LinkReader" id="apidoc.module.fstream.LinkReader">module fstream.LinkReader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.LinkReader.LinkReader" id="apidoc.element.fstream.LinkReader.LinkReader">
        function <span class="apidocSignatureSpan">fstream.</span>LinkReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkReader(props) {
  var self = this
  if (!(self instanceof LinkReader)) {
    throw new Error('LinkReader must be called as constructor.')
  }

  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkReader.super_" id="apidoc.element.fstream.LinkReader.super_">
        function <span class="apidocSignatureSpan">fstream.LinkReader.</span>super_
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.LinkReader.prototype" id="apidoc.module.fstream.LinkReader.prototype">module fstream.LinkReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.LinkReader.prototype._read" id="apidoc.element.fstream.LinkReader.prototype._read">
        function <span class="apidocSignatureSpan">fstream.LinkReader.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  var self = this
  if (self._paused) return
  // basically just a no-op, since we got all the info we need
  // from the _stat method
  if (!self._ended) {
    self.emit('end')
    self.emit('close')
    self._ended = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkReader.prototype._stat" id="apidoc.element.fstream.LinkReader.prototype._stat">
        function <span class="apidocSignatureSpan">fstream.LinkReader.prototype.</span>_stat
        <span class="apidocSignatureSpan">(currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stat = function (currentStat) {
  var self = this
  fs.readlink(self._path, function (er, linkpath) {
    if (er) return self.error(er)
    self.linkpath = self.props.linkpath = linkpath
    self.emit('linkpath', linkpath)
    Reader.prototype._stat.call(self, currentStat)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.LinkWriter" id="apidoc.module.fstream.LinkWriter">module fstream.LinkWriter</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.LinkWriter.LinkWriter" id="apidoc.element.fstream.LinkWriter.LinkWriter">
        function <span class="apidocSignatureSpan">fstream.</span>LinkWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkWriter(props) {
  var self = this
  if (!(self instanceof LinkWriter)) {
    throw new Error('LinkWriter must be called as constructor.')
  }

  // should already be established as a Link type
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  if (props.linkpath === '') props.linkpath = '.'
  if (!props.linkpath) {
    self.error('Need linkpath property to create ' + props.type)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkWriter.super_" id="apidoc.element.fstream.LinkWriter.super_">
        function <span class="apidocSignatureSpan">fstream.LinkWriter.</span>super_
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.LinkWriter.prototype" id="apidoc.module.fstream.LinkWriter.prototype">module fstream.LinkWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.LinkWriter.prototype._create" id="apidoc.element.fstream.LinkWriter.prototype._create">
        function <span class="apidocSignatureSpan">fstream.LinkWriter.prototype.</span>_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_create = function () {
  // console.error(" LW _create")
  var self = this
  var hard = self.type === 'Link' || process.platform === 'win32'
  var link = hard ? 'link' : 'symlink'
  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath

  // can only change the link path by clobbering
  // For hard links, let's just assume that's always the case, since
  // there's no good way to read them if we don't already know.
  if (hard) return clobber(self, lp, link)

  fs.readlink(self._path, function (er, p) {
    // only skip creation if it's exactly the same link
    if (p &amp;&amp; p === lp) return finish(self)
    clobber(self, lp, link)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.LinkWriter.prototype.end" id="apidoc.element.fstream.LinkWriter.prototype.end">
        function <span class="apidocSignatureSpan">fstream.LinkWriter.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  // console.error("LW finish in end")
  this._ended = true
  if (this.ready) {
    this._finished = true
    this._finish()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .<span class="apidocCodeKeywordSpan">end</span>()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Proxy" id="apidoc.module.fstream.Proxy">module fstream.Proxy</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Proxy.Reader" id="apidoc.element.fstream.Proxy.Reader">
        function <span class="apidocSignatureSpan">fstream.Proxy.</span>Reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyReader(props) {
  var self = this
  if (!(self instanceof ProxyReader)) {
    throw new Error('ProxyReader must be called as constructor.')
  }

  self.props = props
  self._buffer = []
  self.ready = false

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Proxy.Writer" id="apidoc.element.fstream.Proxy.Writer">
        function <span class="apidocSignatureSpan">fstream.Proxy.</span>Writer
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyWriter(props) {
  var self = this
  if (!(self instanceof ProxyWriter)) {
    throw new Error('ProxyWriter must be called as constructor.')
  }

  self.props = props
  self._needDrain = false

  Writer.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.ProxyReader" id="apidoc.module.fstream.ProxyReader">module fstream.ProxyReader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.ProxyReader" id="apidoc.element.fstream.ProxyReader.ProxyReader">
        function <span class="apidocSignatureSpan">fstream.</span>ProxyReader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyReader(props) {
  var self = this
  if (!(self instanceof ProxyReader)) {
    throw new Error('ProxyReader must be called as constructor.')
  }

  self.props = props
  self._buffer = []
  self.ready = false

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.super_" id="apidoc.element.fstream.ProxyReader.super_">
        function <span class="apidocSignatureSpan">fstream.ProxyReader.</span>super_
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.ProxyReader.prototype" id="apidoc.module.fstream.ProxyReader.prototype">module fstream.ProxyReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.prototype._addProxy" id="apidoc.element.fstream.ProxyReader.prototype._addProxy">
        function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>_addProxy
        <span class="apidocSignatureSpan">(proxy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addProxy = function (proxy) {
  var self = this
  if (self._proxyTarget) {
    return self.error('proxy already set')
  }

  self._proxyTarget = proxy
  proxy._proxy = self

  ;[
    'error',
    'data',
    'end',
    'close',
    'linkpath',
    'entry',
    'entryEnd',
    'child',
    'childEnd',
    'warn',
    'stat'
  ].forEach(function (ev) {
    // console.error('~~ proxy event', ev, self.path)
    proxy.on(ev, self.emit.bind(self, ev))
  })

  self.emit('proxy', proxy)

  proxy.on('ready', function () {
    // console.error("~~ proxy is ready!", self.path)
    self.ready = true
    self.emit('ready')
  })

  var calls = self._buffer
  self._buffer.length = 0
  calls.forEach(function (c) {
    proxy[c[0]].apply(proxy, c[1])
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.prototype._stat" id="apidoc.element.fstream.ProxyReader.prototype._stat">
        function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>_stat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stat = function () {
  var self = this
  var props = self.props
  // stat the thing to see what the proxy should be.
  var stat = props.follow ? 'stat' : 'lstat'

  fs[stat](props.path, function (er, current) {
    var type
    if (er || !current) {
      type = 'File'
    } else {
      type = getType(current)
    }

    props[type] = true
    props.type = self.type = type

    self._old = current
    self._addProxy(Reader(props, current))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.prototype.pause" id="apidoc.element.fstream.ProxyReader.prototype.pause">
        function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  return this._proxyTarget ? this._proxyTarget.pause() : false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function collect (stream) {
if (stream._collected) return

if (stream._paused) return stream.on('resume', collect.bind(null, stream))

stream._collected = true
stream.<span class="apidocCodeKeywordSpan">pause</span>()

stream.on('data', save)
stream.on('end', save)
var buf = []
function save (b) {
  if (typeof b === 'string') b = new Buffer(b)
  if (Buffer.isBuffer(b) &amp;&amp; !b.length) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyReader.prototype.resume" id="apidoc.element.fstream.ProxyReader.prototype.resume">
        function <span class="apidocSignatureSpan">fstream.ProxyReader.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  return this._proxyTarget ? this._proxyTarget.resume() : false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.<span class="apidocCodeKeywordSpan">resume</span>()
      }

      return dest
    }
  })(stream.pipe)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.ProxyWriter" id="apidoc.module.fstream.ProxyWriter">module fstream.ProxyWriter</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.ProxyWriter" id="apidoc.element.fstream.ProxyWriter.ProxyWriter">
        function <span class="apidocSignatureSpan">fstream.</span>ProxyWriter
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyWriter(props) {
  var self = this
  if (!(self instanceof ProxyWriter)) {
    throw new Error('ProxyWriter must be called as constructor.')
  }

  self.props = props
  self._needDrain = false

  Writer.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.super_" id="apidoc.element.fstream.ProxyWriter.super_">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.</span>super_
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.ProxyWriter.prototype" id="apidoc.module.fstream.ProxyWriter.prototype">module fstream.ProxyWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.prototype._addProxy" id="apidoc.element.fstream.ProxyWriter.prototype._addProxy">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>_addProxy
        <span class="apidocSignatureSpan">(proxy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addProxy = function (proxy) {
  // console.error("~~ set proxy", this.path)
  var self = this
  if (self._proxy) {
    return self.error('proxy already set')
  }

  self._proxy = proxy
  ;[
    'ready',
    'error',
    'close',
    'pipe',
    'drain',
    'warn'
  ].forEach(function (ev) {
    proxy.on(ev, self.emit.bind(self, ev))
  })

  self.emit('proxy', proxy)

  var calls = self._buffer
  calls.forEach(function (c) {
    // console.error("~~ ~~ proxy buffered call", c[0], c[1])
    proxy[c[0]].apply(proxy, c[1])
  })
  self._buffer.length = 0
  if (self._needsDrain) self.emit('drain')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.prototype._stat" id="apidoc.element.fstream.ProxyWriter.prototype._stat">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>_stat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stat = function () {
  var self = this
  var props = self.props
  // stat the thing to see what the proxy should be.
  var stat = props.follow ? 'stat' : 'lstat'

  fs[stat](props.path, function (er, current) {
    var type
    if (er || !current) {
      type = 'File'
    } else {
      type = getType(current)
    }

    props[type] = true
    props.type = self.type = type

    self._old = current
    self._addProxy(Writer(props, current))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.prototype.add" id="apidoc.element.fstream.ProxyWriter.prototype.add">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>add
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (entry) {
  // console.error("~~ proxy add")
  collect(entry)

  if (!this._proxy) {
    this._buffer.push(['add', [entry]])
    this._needDrain = true
    return false
  }
  return this._proxy.add(entry)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Once they're all done, then we can resume completely.
var e = 0
;(function unblockEntry () {
  var entry = entryBuffer[e++]
  // console.error(" ==== unblock entry", entry &amp;&amp; entry.path)
  if (!entry) return resume()
  entry.on('end', unblockEntry)
  if (dest) dest.<span class="apidocCodeKeywordSpan">add</span>(entry)
  else stream.emit('entry', entry)
})()

function resume () {
  stream.removeListener('entry', saveEntry)
  stream.removeListener('data', save)
  stream.removeListener('end', save)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.prototype.end" id="apidoc.element.fstream.ProxyWriter.prototype.end">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>end
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (c) {
  // console.error('~~ proxy end')
  if (!this._proxy) {
    this._buffer.push(['end', [c]])
    return false
  }
  return this._proxy.end(c)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .<span class="apidocCodeKeywordSpan">end</span>()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.ProxyWriter.prototype.write" id="apidoc.element.fstream.ProxyWriter.prototype.write">
        function <span class="apidocSignatureSpan">fstream.ProxyWriter.prototype.</span>write
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (c) {
  // console.error('~~ proxy write')
  if (!this._proxy) {
    this._buffer.push(['write', [c]])
    this._needDrain = true
    return false
  }
  return this._proxy.write(c)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .<span class="apidocCodeKeywordSpan">write</span>("hello\n")
  .end()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Reader" id="apidoc.module.fstream.Reader">module fstream.Reader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Reader.Reader" id="apidoc.element.fstream.Reader.Reader">
        function <span class="apidocSignatureSpan">fstream.</span>Reader
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

So, for example, you can "write" a directory, and it'll call `mkdir`.  You
can specify a uid and gid, and it'll call `chown`.  You can specify a
`mtime` and `atime`, and it'll call `utimes`.  You can call it a symlink
and provide a `linkpath` and it'll call `symlink`.

Note that it won't automatically resolve symbolic links.  So, if you
call `fstream.<span class="apidocCodeKeywordSpan">Reader</span>('/some/symlink')` then you'll get an object
that stats and then ends immediately (since it has no data).  To follow
symbolic links, do this: `fstream.Reader({path:'/some/symlink', follow:
true })`.

There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.Dir" id="apidoc.element.fstream.Reader.Dir">
        function <span class="apidocSignatureSpan">fstream.Reader.</span>Dir
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirReader(props) {
  var self = this
  if (!(self instanceof DirReader)) {
    throw new Error('DirReader must be called as constructor.')
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    throw new Error('Non-directory type ' + props.type)
  }

  self.entries = null
  self._index = -1
  self._paused = false
  self._length = -1

  if (props.sort) {
    this.sort = props.sort
  }

  Reader.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.File" id="apidoc.element.fstream.Reader.File">
        function <span class="apidocSignatureSpan">fstream.Reader.</span>File
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileReader(props) {
  // console.error("    FR create", props.path, props.size, new Error().stack)
  var self = this
  if (!(self instanceof FileReader)) {
    throw new Error('FileReader must be called as constructor.')
  }

  // should already be established as a File type
  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
  // with a HardLinkReader class.
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'File' &amp;&amp; props.File))) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesEmitted = 0
  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.Link" id="apidoc.element.fstream.Reader.Link">
        function <span class="apidocSignatureSpan">fstream.Reader.</span>Link
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkReader(props) {
  var self = this
  if (!(self instanceof LinkReader)) {
    throw new Error('LinkReader must be called as constructor.')
  }

  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.Proxy" id="apidoc.element.fstream.Reader.Proxy">
        function <span class="apidocSignatureSpan">fstream.Reader.</span>Proxy
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyReader(props) {
  var self = this
  if (!(self instanceof ProxyReader)) {
    throw new Error('ProxyReader must be called as constructor.')
  }

  self.props = props
  self._buffer = []
  self.ready = false

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.super_" id="apidoc.element.fstream.Reader.super_">
        function <span class="apidocSignatureSpan">fstream.Reader.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Abstract() {
  Stream.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Reader.prototype" id="apidoc.module.fstream.Reader.prototype">module fstream.Reader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Reader.prototype._read" id="apidoc.element.fstream.Reader.prototype._read">
        function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  this.error('Cannot read unknown type: ' + this.type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.prototype._stat" id="apidoc.element.fstream.Reader.prototype._stat">
        function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>_stat
        <span class="apidocSignatureSpan">(currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stat = function (currentStat) {
  var self = this
  var props = self.props
  var stat = props.follow ? 'stat' : 'lstat'
  // console.error("Reader._stat", self._path, currentStat)
  if (currentStat) process.nextTick(statCb.bind(null, null, currentStat))
  else fs[stat](self._path, statCb)

  function statCb (er, props_) {
    // console.error("Reader._stat, statCb", self._path, props_, props_.nlink)
    if (er) return self.error(er)

    Object.keys(props_).forEach(function (k) {
      props[k] = props_[k]
    })

    // if it's not the expected size, then abort here.
    if (undefined !== self.size &amp;&amp; props.size !== self.size) {
      return self.error('incorrect size')
    }
    self.size = props.size

    var type = getType(props)
    var handleHardlinks = props.hardlinks !== false

    // special little thing for handling hardlinks.
    if (handleHardlinks &amp;&amp; type !== 'Directory' &amp;&amp; props.nlink &amp;&amp; props.nlink &gt; 1) {
      var k = props.dev + ':' + props.ino
      // console.error("Reader has nlink", self._path, k)
      if (hardLinks[k] === self._path || !hardLinks[k]) {
        hardLinks[k] = self._path
      } else {
        // switch into hardlink mode.
        type = self.type = self.props.type = 'Link'
        self.Link = self.props.Link = true
        self.linkpath = self.props.linkpath = hardLinks[k]
        // console.error("Hardlink detected, switching mode", self._path, self.linkpath)
        // Setting __proto__ would arguably be the "correct"
        // approach here, but that just seems too wrong.
        self._stat = self._read = LinkReader.prototype._read
      }
    }

    if (self.type &amp;&amp; self.type !== type) {
      self.error('Unexpected type: ' + type)
    }

    // if the filter doesn't pass, then just skip over this one.
    // still have to emit end so that dir-walking can move on.
    if (self.filter) {
      var who = self._proxy || self
      // special handling for ProxyReaders
      if (!self.filter.call(who, who, props)) {
        if (!self._disowned) {
          self.abort()
          self.emit('end')
          self.emit('close')
        }
        return
      }
    }

    // last chance to abort or disown before the flow starts!
    var events = ['_stat', 'stat', 'ready']
    var e = 0
    ;(function go () {
      if (self._aborted) {
        self.emit('end')
        self.emit('close')
        return
      }

      if (self._paused &amp;&amp; self.type !== 'Directory') {
        self.once('resume', go)
        return
      }

      var ev = events[e++]
      if (!ev) {
        return self._read()
      }
      self.emit(ev, props)
      go()
    })()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.prototype.pause" id="apidoc.element.fstream.Reader.prototype.pause">
        function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>pause
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (who) {
  this._paused = true
  who = who || this
  this.emit('pause', who)
  if (this._stream) this._stream.pause(who)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function collect (stream) {
if (stream._collected) return

if (stream._paused) return stream.on('resume', collect.bind(null, stream))

stream._collected = true
stream.<span class="apidocCodeKeywordSpan">pause</span>()

stream.on('data', save)
stream.on('end', save)
var buf = []
function save (b) {
  if (typeof b === 'string') b = new Buffer(b)
  if (Buffer.isBuffer(b) &amp;&amp; !b.length) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.prototype.pipe" id="apidoc.element.fstream.Reader.prototype.pipe">
        function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest) {
  var self = this
  if (typeof dest.add === 'function') {
    // piping to a multi-compatible, and we've got directory entries.
    self.on('entry', function (entry) {
      var ret = dest.add(entry)
      if (ret === false) {
        self.pause()
      }
    })
  }

  // console.error("R Pipe apply Stream Pipe")
  return Stream.prototype.pipe.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Note that the linkpath is relative to the symbolic link location, not
the parent dir or cwd.

```javascript
fstream
  .Reader("path/to/dir")
  .<span class="apidocCodeKeywordSpan">pipe</span>(fstream.Writer("path/to/other/dir"))
```

This will do like `cp -Rp path/to/dir path/to/other/dir`.  If the other
dir exists and isn't a directory, then it'll emit an error.  It'll also
set the uid, gid, mode, etc. to be identical.  In this way, it's more
like `rsync -a` than simply a copy.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Reader.prototype.resume" id="apidoc.element.fstream.Reader.prototype.resume">
        function <span class="apidocSignatureSpan">fstream.Reader.prototype.</span>resume
        <span class="apidocSignatureSpan">(who)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (who) {
  this._paused = false
  who = who || this
  this.emit('resume', who)
  if (this._stream) this._stream.resume(who)
  this._read()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (dest) stream.pipe(dest)

        buf.forEach(function (b) {
          if (b) stream.emit('data', b)
          else stream.emit('end')
        })

        stream.<span class="apidocCodeKeywordSpan">resume</span>()
      }

      return dest
    }
  })(stream.pipe)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Writer" id="apidoc.module.fstream.Writer">module fstream.Writer</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Writer.Writer" id="apidoc.element.fstream.Writer.Writer">
        function <span class="apidocSignatureSpan">fstream.</span>Writer
        <span class="apidocSignatureSpan">(props, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(props, current) {
  var self = this

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Writer(dir) to get a DirWriter object, etc.
  var type = getType(props)
  var ClassType = Writer

  switch (type) {
    case 'Directory':
      ClassType = DirWriter
      break
    case 'File':
      ClassType = FileWriter
      break
    case 'Link':
    case 'SymbolicLink':
      ClassType = LinkWriter
      break
    case null:
    default:
      // Don't know yet what type to create, so we wrap in a proxy.
      ClassType = ProxyWriter
      break
  }

  if (!(self instanceof ClassType)) return new ClassType(props)

  // now get down to business.

  Abstract.call(self)

  if (!props.path) self.error('Must provide a path', null, true)

  // props is what we want to set.
  // set some convenience properties as well.
  self.type = props.type
  self.props = props
  self.depth = props.depth || 0
  self.clobber = props.clobber === false ? props.clobber : true
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      self._swallowErrors = true
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    }
  }
  self.basename = path.basename(props.path)
  self.dirname = path.dirname(props.path)
  self.linkpath = props.linkpath || null

  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size

  if (typeof props.mode === 'string') {
    props.mode = parseInt(props.mode, 8)
  }

  self.readable = false
  self.writable = true

  // buffer until ready, or while handling another entry
  self._buffer = []
  self.ready = false

  self.filter = typeof props.filter === 'function' ? props.filter : null

  // start the ball rolling.
  // this checks what's there already, and then calls
  // self._create() to call the impl-specific creation stuff.
  self._stat(current)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are various checks to make sure that the bytes emitted are the
same as the intended size, if the size is set.

## Examples

```javascript
fstream
  .<span class="apidocCodeKeywordSpan">Writer</span>({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .write("hello\n")
  .end()
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.Dir" id="apidoc.element.fstream.Writer.Dir">
        function <span class="apidocSignatureSpan">fstream.Writer.</span>Dir
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DirWriter(props) {
  var self = this
  if (!(self instanceof DirWriter)) {
    self.error('DirWriter must be called as constructor.', null, true)
  }

  // should already be established as a Directory type
  if (props.type !== 'Directory' || !props.Directory) {
    self.error('Non-directory type ' + props.type + ' ' +
      JSON.stringify(props), null, true)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.File" id="apidoc.element.fstream.Writer.File">
        function <span class="apidocSignatureSpan">fstream.Writer.</span>File
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileWriter(props) {
  var self = this
  if (!(self instanceof FileWriter)) {
    throw new Error('FileWriter must be called as constructor.')
  }

  // should already be established as a File type
  if (props.type !== 'File' || !props.File) {
    throw new Error('Non-file type ' + props.type)
  }

  self._buffer = []
  self._bytesWritten = 0

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.Link" id="apidoc.element.fstream.Writer.Link">
        function <span class="apidocSignatureSpan">fstream.Writer.</span>Link
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkWriter(props) {
  var self = this
  if (!(self instanceof LinkWriter)) {
    throw new Error('LinkWriter must be called as constructor.')
  }

  // should already be established as a Link type
  if (!((props.type === 'Link' &amp;&amp; props.Link) ||
    (props.type === 'SymbolicLink' &amp;&amp; props.SymbolicLink))) {
    throw new Error('Non-link type ' + props.type)
  }

  if (props.linkpath === '') props.linkpath = '.'
  if (!props.linkpath) {
    self.error('Need linkpath property to create ' + props.type)
  }

  Writer.call(this, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.Proxy" id="apidoc.element.fstream.Writer.Proxy">
        function <span class="apidocSignatureSpan">fstream.Writer.</span>Proxy
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyWriter(props) {
  var self = this
  if (!(self instanceof ProxyWriter)) {
    throw new Error('ProxyWriter must be called as constructor.')
  }

  self.props = props
  self._needDrain = false

  Writer.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.super_" id="apidoc.element.fstream.Writer.super_">
        function <span class="apidocSignatureSpan">fstream.Writer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Abstract() {
  Stream.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.Writer.prototype" id="apidoc.module.fstream.Writer.prototype">module fstream.Writer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype._create" id="apidoc.element.fstream.Writer.prototype._create">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_create = function () {
  var self = this
  fs[self.props.follow ? 'stat' : 'lstat'](self._path, function (er) {
    if (er) {
      return self.warn('Cannot create ' + self._path + '\n' +
        'Unsupported type: ' + self.type, 'ENOTSUP')
    }
    self._finish()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype._finish" id="apidoc.element.fstream.Writer.prototype._finish">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_finish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finish = function () {
  var self = this

  if (self._finishing) return
  self._finishing = true

  // console.error(" W Finish", self._path, self.size)

  // set up all the things.
  // At this point, we're already done writing whatever we've gotta write,
  // adding files to the dir, etc.
  var todo = 0
  var errState = null
  var done = false

  if (self._old) {
    // the times will almost *certainly* have changed.
    // adds the utimes syscall, but remove another stat.
    self._old.atime = new Date(0)
    self._old.mtime = new Date(0)
    // console.error(" W Finish Stale Stat", self._path, self.size)
    setProps(self._old)
  } else {
    var stat = self.props.follow ? 'stat' : 'lstat'
    // console.error(" W Finish Stating", self._path, self.size)
    fs[stat](self._path, function (er, current) {
      // console.error(" W Finish Stated", self._path, self.size, current)
      if (er) {
        // if we're in the process of writing out a
        // directory, it's very possible that the thing we're linking to
        // doesn't exist yet (especially if it was intended as a symlink),
        // so swallow ENOENT errors here and just soldier on.
        if (er.code === 'ENOENT' &amp;&amp;
          (self.type === 'Link' || self.type === 'SymbolicLink') &amp;&amp;
          process.platform === 'win32') {
          self.ready = true
          self.emit('ready')
          self.emit('end')
          self.emit('close')
          self.end = self._finish = function () {}
          return
        } else return self.error(er)
      }
      setProps(self._old = current)
    })
  }

  return

  function setProps (current) {
    todo += 3
    endChmod(self, self.props, current, self._path, next('chmod'))
    endChown(self, self.props, current, self._path, next('chown'))
    endUtimes(self, self.props, current, self._path, next('utimes'))
  }

  function next (what) {
    return function (er) {
      // console.error("   W Finish", what, todo)
      if (errState) return
      if (er) {
        er.fstream_finish_call = what
        return self.error(errState = er)
      }
      if (--todo &gt; 0) return
      if (done) return
      done = true

      // we may still need to set the mode/etc. on some parent dirs
      // that were created previously.  delay end/close until then.
      if (!self._madeDir) return end()
      else endMadeDir(self, self._path, end)

      function end (er) {
        if (er) {
          er.fstream_finish_call = 'setupMadeDir'
          return self.error(er)
        }
        // all the props have been set, so we're completely done.
        self.emit('end')
        self.emit('close')
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype._stat" id="apidoc.element.fstream.Writer.prototype._stat">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>_stat
        <span class="apidocSignatureSpan">(current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stat = function (current) {
  var self = this
  var props = self.props
  var stat = props.follow ? 'stat' : 'lstat'
  var who = self._proxy || self

  if (current) statCb(null, current)
  else fs[stat](self._path, statCb)

  function statCb (er, current) {
    if (self.filter &amp;&amp; !self.filter.call(who, who, current)) {
      self._aborted = true
      self.emit('end')
      self.emit('close')
      return
    }

    // if it's not there, great.  We'll just create it.
    // if it is there, then we'll need to change whatever differs
    if (er || !current) {
      return create(self)
    }

    self._old = current
    var currentType = getType(current)

    // if it's a type change, then we need to clobber or error.
    // if it's not a type change, then let the impl take care of it.
    if (currentType !== self.type) {
      return rimraf(self._path, function (er) {
        if (er) return self.error(er)
        self._old = null
        create(self)
      })
    }

    // otherwise, just handle in the app-specific way
    // this creates a fs.WriteStream, or mkdir's, or whatever
    create(self)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype.add" id="apidoc.element.fstream.Writer.prototype.add">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  this.error("Can't add to non-Directory type")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Once they're all done, then we can resume completely.
var e = 0
;(function unblockEntry () {
  var entry = entryBuffer[e++]
  // console.error(" ==== unblock entry", entry &amp;&amp; entry.path)
  if (!entry) return resume()
  entry.on('end', unblockEntry)
  if (dest) dest.<span class="apidocCodeKeywordSpan">add</span>(entry)
  else stream.emit('entry', entry)
})()

function resume () {
  stream.removeListener('entry', saveEntry)
  stream.removeListener('data', save)
  stream.removeListener('end', save)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype.pipe" id="apidoc.element.fstream.Writer.prototype.pipe">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {
  this.error("Can't pipe from writable stream")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Note that the linkpath is relative to the symbolic link location, not
the parent dir or cwd.

```javascript
fstream
  .Reader("path/to/dir")
  .<span class="apidocCodeKeywordSpan">pipe</span>(fstream.Writer("path/to/other/dir"))
```

This will do like `cp -Rp path/to/dir path/to/other/dir`.  If the other
dir exists and isn't a directory, then it'll emit an error.  It'll also
set the uid, gid, mode, etc. to be identical.  In this way, it's more
like `rsync -a` than simply a copy.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.Writer.prototype.write" id="apidoc.element.fstream.Writer.prototype.write">
        function <span class="apidocSignatureSpan">fstream.Writer.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
fstream
  .Writer({ path: "path/to/file"
          , mode: 0755
          , size: 6
          })
  .<span class="apidocCodeKeywordSpan">write</span>("hello\n")
  .end()
```

This will create the directories if they're missing, and then write
`hello\n` into the file, chmod it to 0755, and assert that 6 bytes have
been written when it's done.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.socket_reader" id="apidoc.module.fstream.socket_reader">module fstream.socket_reader</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.socket_reader.socket_reader" id="apidoc.element.fstream.socket_reader.socket_reader">
        function <span class="apidocSignatureSpan">fstream.</span>socket_reader
        <span class="apidocSignatureSpan">(props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketReader(props) {
  var self = this
  if (!(self instanceof SocketReader)) {
    throw new Error('SocketReader must be called as constructor.')
  }

  if (!(props.type === 'Socket' &amp;&amp; props.Socket)) {
    throw new Error('Non-socket type ' + props.type)
  }

  Reader.call(self, props)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fstream.socket_reader.super_" id="apidoc.element.fstream.socket_reader.super_">
        function <span class="apidocSignatureSpan">fstream.socket_reader.</span>super_
        <span class="apidocSignatureSpan">(props, currentStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(props, currentStat) {
  var self = this
  if (!(self instanceof Reader)) return new Reader(props, currentStat)

  if (typeof props === 'string') {
    props = { path: props }
  }

  // polymorphism.
  // call fstream.Reader(dir) to get a DirReader object, etc.
  // Note that, unlike in the Writer case, ProxyReader is going
  // to be the *normal* state of affairs, since we rarely know
  // the type of a file prior to reading it.

  var type
  var ClassType

  if (props.type &amp;&amp; typeof props.type === 'function') {
    type = props.type
    ClassType = type
  } else {
    type = getType(props)
    ClassType = Reader
  }

  if (currentStat &amp;&amp; !type) {
    type = getType(currentStat)
    props[type] = true
    props.type = type
  }

  switch (type) {
    case 'Directory':
      ClassType = require('./dir-reader.js')
      break

    case 'Link':
    // XXX hard links are just files.
    // However, it would be good to keep track of files' dev+inode
    // and nlink values, and create a HardLinkReader that emits
    // a linkpath value of the original copy, so that the tar
    // writer can preserve them.
    // ClassType = HardLinkReader
    // break

    case 'File':
      ClassType = require('./file-reader.js')
      break

    case 'SymbolicLink':
      ClassType = LinkReader
      break

    case 'Socket':
      ClassType = require('./socket-reader.js')
      break

    case null:
      ClassType = require('./proxy-reader.js')
      break
  }

  if (!(self instanceof ClassType)) {
    return new ClassType(props)
  }

  Abstract.call(self)

  if (!props.path) {
    self.error('Must provide a path', null, true)
  }

  self.readable = true
  self.writable = false

  self.type = type
  self.props = props
  self.depth = props.depth = props.depth || 0
  self.parent = props.parent || null
  self.root = props.root || (props.parent &amp;&amp; props.parent.root) || self

  self._path = self.path = path.resolve(props.path)
  if (process.platform === 'win32') {
    self.path = self._path = self.path.replace(/\?/g, '_')
    if (self._path.length &gt;= 260) {
      // how DOES one create files on the moon?
      // if the path has spaces in it, then UNC will fail.
      self._swallowErrors = true
      // if (self._path.indexOf(" ") === -1) {
      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
    // }
    }
  }
  self.basename = props.basename = path.basename(self.path)
  self.dirname = props.dirname = path.dirname(self.path)

  // these have served their purpose, and are now just noisy clutter
  props.parent = props.root = null

  // console.error("\n\n\n%s setting size to", props.path, props.size)
  self.size = props.size
  self.filter = typeof props.filter === 'function' ? props.filter : null
  if (props.sort === 'alpha') props.sort = alphasort

  // start the ball rolling.
  // this will stat the thing, and then call self._read()
  // to start reading whatever it is.
  // console.error("calling stat", props.path, currentStat)
  self._stat(currentStat)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fstream.socket_reader.prototype" id="apidoc.module.fstream.socket_reader.prototype">module fstream.socket_reader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fstream.socket_reader.prototype._read" id="apidoc.element.fstream.socket_reader.prototype._read">
        function <span class="apidocSignatureSpan">fstream.socket_reader.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  var self = this
  if (self._paused) return
  // basically just a no-op, since we got all the info we have
  // from the _stat method
  if (!self._ended) {
    self.emit('end')
    self.emit('close')
    self._ended = true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>